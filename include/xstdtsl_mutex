#pragma once
#include <chrono>
#include <thread>

typedef void * xstdtsl_rwm_t;
extern "C"
{
	xstdtsl_rwm_t	xstdtsl_rwm_new_read_write_mutex(void);
	bool	xstdtsl_rwm_is_read_locked(xstdtsl_rwm_t);
	bool	xstdtsl_rwm_is_write_locked(xstdtsl_rwm_t);
	bool	xstdtsl_rwm_is_unlocked(xstdtsl_rwm_t);
	int		xstdtsl_rwm_lock_status(xstdtsl_rwm_t);
	void	xstdtsl_rwm_read_lock(xstdtsl_rwm_t);
	void	xstdtsl_rwm_write_lock(xstdtsl_rwm_t);
	void	xstdtsl_rwm_read_unlock(xstdtsl_rwm_t);
	void	xstdtsl_rwm_write_unlock(xstdtsl_rwm_t);
	bool	xstdtsl_rwm_try_read_lock(xstdtsl_rwm_t);
	bool	xstdtsl_rwm_try_write_lock(xstdtsl_rwm_t);
	void	xstdtsl_rwm_delete_read_write_mutex(xstdtsl_rwm_t &);
	void	xstdtsl_rwm_set_status(xstdtsl_rwm_t, int);
}

namespace xstdtsl
{
	
	///
	/// The read/write mutex is used for atomic like read/write access to complex types. It allows multiple users to have read access while write access is denied, and a single user to have write access while all reads and other writes are denied.
	///

	class read_write_mutex
	{
	private:
		xstdtsl_rwm_t						m_cRW_Mutex;
	public:
		enum class status {unlocked=0,write_locked=-1,maximum_read_lock=-2};
		///
		/// constructor; sets the initial number of read/write users to 0
		///
		read_write_mutex(void) noexcept
		{
			m_cRW_Mutex = xstdtsl_rwm_new_read_write_mutex();
		}
		///
		/// copy constuctor (deleted)
		///
		read_write_mutex(const read_write_mutex & i_RHO) = delete;
		///
		/// assignment operator (deleted)
		///
		read_write_mutex & operator =(const read_write_mutex & i_cRHO) = delete;
		///
		/// destructor; claims write lock to ensure no other read/write users prior to destruction
		///
		~read_write_mutex(void) noexcept
		{
			xstdtsl_rwm_delete_read_write_mutex(m_cRW_Mutex);
		}
		///
		/// checks to see if the mutex is currently read locked; non-blocking
		/// \returns true if the mutex is locked due to reading; false otherwise
		///
		bool is_read_locked(void) const  noexcept
		{
			return xstdtsl_rwm_is_read_locked(m_cRW_Mutex);
		}
		///
		/// checks to see if the mutex is currently write locked; non-blocking
		/// \returns true if the mutex is locked due to writing; false otherwise
		///
		inline bool is_write_locked(void) const noexcept
		{
			return xstdtsl_rwm_is_write_locked(m_cRW_Mutex);
		}
		///
		/// checks to see if the mutex is currently locked for reading or writing; non-blocking
		/// \returns true if the mutex is not locked for reading or writing; false otherwise
		///
		inline bool is_unlocked(void) const noexcept
		{
			return xstdtsl_rwm_is_unlocked(m_cRW_Mutex);
		}
		///
		/// gets the current number of users of the read or write lock
		/// \returns 0 if no read or write locks exist; -1 if a write lock exists; and a number > 0 or <= -2 if a read lock exists. If the number is negative, there are (std::numeric_limits<int>.max() + (<return value> - std::numeric_limits<int>.min())) users
		///
		int get_lock_status(void) const noexcept
		{
			return xstdtsl_rwm_lock_status(m_cRW_Mutex);
		}
		///
		/// tests the lock status against known status (unlocked, write_locked, or maximally_read_locked)
		/// \returns true if the status matches the desired value; false otherwise
		///
		bool test_lock_status(status i_eStatus) const noexcept
		{
			return xstdtsl_rwm_lock_status(m_cRW_Mutex) == (int)i_eStatus;
		}

		///
		/// set the current status of the lock
		/// this function should be used only for testing and never in production code
		///
		void set_lock_status(int i_nStatus) noexcept
		{
			xstdtsl_rwm_set_status(m_cRW_Mutex,i_nStatus);
		}

		///
		/// attemps to obtain a read lock; non-blocking
		/// \returns true if a read lock is obtained; false otherwise
		///
		bool try_read_lock(void) const noexcept
		{
			return xstdtsl_rwm_try_read_lock(m_cRW_Mutex);
		}
		///
		/// attemps to obtain a write lock; non-blocking
		/// \returns true if a write lock is obtained; false otherwise
		///
		bool try_write_lock(void) const noexcept
		{
			return xstdtsl_rwm_try_write_lock(m_cRW_Mutex);
		}
		///
		/// obtains a read lock; blocking
		///
		void read_lock (void) const noexcept
		{
			xstdtsl_rwm_read_lock(m_cRW_Mutex);
		}
		///
		/// obtains a write lock; blocking
		///
		void write_lock (void) const noexcept
		{
			xstdtsl_rwm_write_lock(m_cRW_Mutex);
		}
		///
		/// releases a read lock; blocking
		///
		void read_unlock(void) const noexcept
		{
			xstdtsl_rwm_read_unlock(m_cRW_Mutex);
		}
		///
		/// releases a write lock; blocking
		///
		void write_unlock(void) const noexcept
		{
			xstdtsl_rwm_write_unlock(m_cRW_Mutex);
		}
		///
		/// attemps to obtain a read lock for a fixed duration; blocking for the duration
		/// \returns true if a read lock is obtained; false otherwise
		///
		template <class Rep,class Period> bool try_read_lock_for( const std::chrono::duration<Rep,Period>& i_cTimeout_Duration ) noexcept
		{
			auto tStart = std::chrono::steady_clock::now();
			bool bRet = try_read_lock();
			while (!bRet && (std::chrono::steady_clock::now() - tStart) < i_cTimeout_Duration)
			{
				std::this_thread::yield();
				bRet = try_read_lock();
			}
			return bRet;
		}
		///
		/// attemps to obtain a write lock for a fixed duration; blocking for the duration
		/// \returns true if a write lock is obtained; false otherwise
		///
		template <class Rep,class Period> bool try_write_lock_for( const std::chrono::duration<Rep,Period>& i_cTimeout_Duration ) noexcept
		{
			auto tStart = std::chrono::steady_clock::now();
			bool bRet = try_write_lock();
			while (!bRet && (std::chrono::steady_clock::now() - tStart) < i_cTimeout_Duration)
			{
				std::this_thread::yield();
				bRet = try_write_lock();
			}
			return bRet;
		}
		///
		/// attemps to obtain a read lock until a certain time; blocking for the duration
		/// \returns true if a read lock is obtained; false otherwise
		///

		template <class Clock,class Duration> bool try_read_lock_until( const std::chrono::time_point<Clock,Duration>& i_cTimeout_Time ) noexcept
		{
			bool bRet = try_read_lock();
			while (!bRet && Clock::now() < i_cTimeout_Time)
			{
				std::this_thread::yield();
				bRet = try_read_lock();
			}
			return bRet;
		}
		///
		/// attemps to obtain a write lock until a certain time; blocking for the duration
		/// \returns true if a write lock is obtained; false otherwise
		///
		template <class Clock,class Duration>bool try_write_lock_until( const std::chrono::time_point<Clock,Duration>& i_cTimeout_Time ) noexcept
		{
			bool bRet = try_write_lock();
			while (!bRet && Clock::now() < i_cTimeout_Time)
			{
				std::this_thread::yield();
				bRet = try_write_lock();
			}
			return bRet;
		}
	};


	///
	/// similar to std::lock_guard, but claiming read access for a read_write_mutex
	///
	class read_lock_guard
	{
	private:
		read_write_mutex & m_tMutex; ///< a reference to the mutex to use
	public:
		///
		/// constructor; establishes a read lock; blocking
		///
		explicit read_lock_guard(read_write_mutex & i_tMutex) noexcept : m_tMutex(i_tMutex)
		{
			m_tMutex.read_lock();
		}
		///
		/// copy constructor; deleted
		///
		read_lock_guard(const read_lock_guard & i_cRHO) = delete;
		///
		/// assignment operator; deleted
		///
		read_lock_guard operator =(const read_lock_guard & i_cRHO) = delete;
		///
		/// destructor; releases a read lock; blocking
		///
		~read_lock_guard(void) noexcept
		{
			m_tMutex.read_unlock();
		}
	};

	///
	/// similar to std::lock_guard, but claiming read access for a read_write_mutex
	///
	class write_lock_guard
	{
	private:
		read_write_mutex & m_tMutex; ///< a reference to the mutex to use
	public:
		///
		/// constructor; establishes a read lock; blocking
		///
		explicit write_lock_guard(read_write_mutex & i_tMutex) noexcept : m_tMutex(i_tMutex)
		{
			m_tMutex.write_lock();
		}
		///
		/// copy constructor; deleted
		///
		write_lock_guard(const write_lock_guard & i_cRHO) = delete;
		///
		/// assignment operator; deleted
		///
		write_lock_guard operator =(const write_lock_guard & i_cRHO) = delete;
		///
		/// destructor; releases a read lock; blocking
		///
		~write_lock_guard(void) noexcept
		{
			m_tMutex.write_unlock();
		}
	};
#if 0 // this requires c++17 or c++20
	///
	/// similar to std::lock, but attempts to perform a read lock on multiple read_write_mutex or similar locks that have member try_read_lock()
	/// \returns -1 on success, the index of the lock that was unable to be aquired on partial success or failure
	///
	template<typename lock1, typename lock2, typename... lock3> int try_read_lock(lock1& i_l1, lock2& i_l2, lock3&... i_l3) noexcept
    {
		size_t nIdx = -1;
		bool bSuccess = true;
		auto tLocks = std::tie(i_l1, i_l2, i_l3...);
		do
		{
			bSuccess = std::get<nIdx>(tLocks).try_read_lock();
			nIdx++;
		}
		while (bSuccess && nIdx < std::tuple_size<tLocks>::value)
		if (bSuccess)
			nIdx = -1;
		else
			nIdx--;
		return nIdx;
    }
	///
	/// similar to std::lock, but attempts to perform a read lock on multiple read_write_mutex or similar locks that have member try_read_lock()
	/// \returns -1 on success, the index of the lock that was unable to be aquired on partial success or failure
	///
	template<typename lock1, typename lock2, typename... lock3> int try_write_lock(lock1& i_l1, lock2& i_l2, lock3&... i_l3) noexcept
    {
		size_t nIdx = 0;
		bool bSuccess = true;
		auto tLocks = std::tie(i_l1, i_l2, i_l3...);
		do
		{
			bSuccess = std::get<nIdx>(tLocks).try_write_lock();
			nIdx++;
		}
		while (bSuccess && nIdx < std::tuple_size<tLocks>::value)
		if (bSuccess)
			nIdx = -1;
		else
			nIdx--;
		return nIdx;
    }
	///
	/// similar to std::lock, but performs a read lock on multiple read_write_mutex or similar locks that have member read_lock(); blocking
	///
	template<typename lock1, typename lock2, typename... lock3> void read_lock(lock1& i_l1, lock2& i_l2, lock3&... i_l3) noexcept
    {
		size_t nIdx = 0;
		auto tLocks = std::tie(i_l1, i_l2, i_l3...);
		do
		{
			std::get<nIdx>(tLocks).read_lock();
			nIdx++;
		}
		while (nIdx < std::tuple_size<tLocks>::value)
    }
	///
	/// unlocks multiple read_write_mutex or similar locks that have member read_unlock(); blocking
	///
	template<typename lock1, typename lock2, typename... lock3> void read_unlock(lock1& i_l1, lock2& i_l2, lock3&... i_l3) noexcept
    {
		auto tLocks = std::tie(i_l1, i_l2, i_l3...);
		size_t nIdx = std::tuple_size<tLocks>::value;
		while (nIdx > 0)
		{
			nIdx--;
			std::get<nIdx>(tLocks).read_unlock();
		}
		std::get<0>(tLocks).read_unlock();
    }

	///
	/// similar to std::lock, but performs a write lock on multiple read_write_mutex or similar locks that have member write_lock(); blocking
	///
	template<typename lock1, typename lock2, typename... lock3> void write_lock(lock1& i_l1, lock2& i_l2, lock3&... i_l3) noexcept
    {
		size_t nIdx = 0;
		auto tLocks = std::tie(i_l1, i_l2, i_l3...);
		do
		{
			std::get<nIdx>(tLocks).write_lock();
			nIdx++;
		}
		while (nIdx < std::tuple_size<tLocks>::value)
    }
	///
	/// unlocks multiple read_write_mutex or similar locks that have member write_unlock(); blocking
	///
	template<typename lock1, typename lock2, typename... lock3> void read_unlock(lock1& i_l1, lock2& i_l2, lock3&... i_l3) noexcept
    {
		auto tLocks = std::tie(i_l1, i_l2, i_l3...);
		size_t nIdx = std::tuple_size<tLocks>::value;
		while (nIdx > 0)
		{
			nIdx--;
			std::get<nIdx>(tLocks).write_unlock();
		}
    }
#endif
	///
	/// similar to std::scoped_lock, but operating on two read_write_mutex to gain read lock on both, ensuring a deadlock doesn't occur; blocking
	///
	class dual_read_lock
	{
	private:
		//std::vector<read_write_lock&> m_vMutex_Info; ///< list of all mutex controlled by this lock
		read_write_mutex &m_Mutex1;
		read_write_mutex &m_Mutex2;
	public:
		///
		/// constructor; locks both mutexes for reading; blocking
		///
		dual_read_lock(
			read_write_mutex & i_Mutex1, ///< the first read_write_mutex to lock for writing
			read_write_mutex & i_Mutex2 ///< the second read_write_mutex to lock for writing
			) noexcept : m_Mutex1(i_Mutex1), m_Mutex2(i_Mutex2)
		{
			bool bWhich = true;
			bool bDone = false;
			do
			{
				read_write_mutex * pM1 = &m_Mutex1;
				read_write_mutex * pM2 = &m_Mutex2;
				bWhich = !bWhich;

				if (bWhich)
				{
					pM1 = &m_Mutex2;
					pM2 = &m_Mutex1;
				}

				if (pM1->try_read_lock())
				{
					if (pM2->try_read_lock())
						bDone = true;
					else
					{
						pM1->read_unlock();
						std::this_thread::yield();
					}
				}
				else
					std::this_thread::yield();
			} while (!bDone);
		}
		///
		/// copy constructor; deleted
		///
		dual_read_lock(const dual_read_lock & i_cRHO) = delete;
		///
		/// assignment operator; deleted
		///
		dual_read_lock & operator =(const dual_read_lock & i_cRHO) = delete;
		///
		/// destructor; releases read lock on both mutexes
		///
		~dual_read_lock(void)
		{
			m_Mutex2.read_unlock();
			m_Mutex1.read_unlock();
		}
	};

	///
	/// similar to std::scoped_lock, but operating on two read_write_mutex to gain write lock on both, ensuring a deadlock doesn't occur; blocking
	///
	class dual_write_lock
	{
	private:
		read_write_mutex & m_Mutex1; ///< reference to the first read_write_mutex
		read_write_mutex & m_Mutex2; ///< reference to the second read_write_mutex

	public:
		///
		/// constructor; locks both mutexes for reading; blocking
		///
		dual_write_lock(
			read_write_mutex & i_Mutex1, ///< the first read_write_mutex to lock for writing
			read_write_mutex & i_Mutex2 ///< the second read_write_mutex to lock for writing
			) noexcept : m_Mutex1(i_Mutex1), m_Mutex2(i_Mutex2)
		{
			bool bWhich = true;
			bool bDone = false;
			do
			{
				read_write_mutex * pM1 = &m_Mutex1;
				read_write_mutex * pM2 = &m_Mutex2;
				bWhich = !bWhich;

				if (bWhich)
				{
					pM1 = &m_Mutex2;
					pM2 = &m_Mutex1;
				}

				if (pM1->try_write_lock())
				{
					if (pM2->try_write_lock())
						bDone = true;
					else
					{
						pM1->write_unlock();
						std::this_thread::yield();
					}
				}
				else
					std::this_thread::yield();
			} while (!bDone);
		}
		///
		/// copy constructor; deleted
		///
		dual_write_lock(const dual_write_lock & i_cRHO) = delete;
		///
		/// assignment operator; deleted
		///
		dual_write_lock & operator =(const dual_write_lock & i_cRHO) = delete;
		///
		/// destructor; releases write lock on both mutexes
		///
		~dual_write_lock(void)
		{
			m_Mutex2.write_unlock();
			m_Mutex1.write_unlock();
		}
	};

	///
	/// similar to std::scoped_lock, but operating on two read_write_mutex to gain read lock on one and write lock on the other, ensuring a deadlock doesn't occur; blocking
	///
	class dual_read_write_lock
	{
	private:
		read_write_mutex & m_Mutex_Read; ///< reference to the first read_write_mutex that will be locked for read
		read_write_mutex & m_Mutex_Write; ///< reference to the second read_write_mutex that will be locked for write

	public:
		///
		/// constructor; locks both mutexes for reading; blocking
		///
		dual_read_write_lock(
			read_write_mutex & i_Mutex_Read, ///< the read_write_mutex to lock for reading
			read_write_mutex & i_Mutex_Write ///< the read_write_mutex to lock for writing
			) noexcept : m_Mutex_Read(i_Mutex_Read), m_Mutex_Write(i_Mutex_Write)
		{
			bool bWhich = true;
			bool bDone = false;
			do
			{
				bWhich = !bWhich;

				if (bWhich)
				{
					if (m_Mutex_Write.try_write_lock())
					{
						if (m_Mutex_Read.try_read_lock())
							bDone = true;
						else
						{
							m_Mutex_Write.write_unlock();
						}
					}
				}
				else
				{
					if (m_Mutex_Read.try_read_lock())
					{
						if (m_Mutex_Write.try_write_lock())
							bDone = true;
						else
						{
							m_Mutex_Read.read_unlock();
						}
					}
				}

				if (!bDone)
					std::this_thread::yield();
			} while (!bDone);
		}
		///
		/// copy constructor; deleted
		///
		dual_read_write_lock(const dual_read_write_lock & i_cRHO) = delete;
		///
		/// assignment operator; deleted
		///
		dual_read_write_lock & operator =(const dual_read_write_lock & i_cRHO) = delete;
		///
		/// destructor; releases lock on both mutexes
		///
		~dual_read_write_lock(void)
		{
			m_Mutex_Write.write_unlock();
			m_Mutex_Read.read_unlock();
		}
	};
	
}

