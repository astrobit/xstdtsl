#pragma once
#ifndef XSTDTSL_SAFE_AVL_TREE_H
#define XSTDTSL_SAFE_AVL_TREE_H
#include <xstdtsl_safe_binary_tree>
#include <iostream>
namespace xstdtsl
{
#pragma once
#ifndef __XSTDTSL_SAFE_BINARY_TREE_H
#define __XSTDTSL_SAFE_BINARY_TREE_H

#include <xstdtsl_mutex>
#include <xstdtsl_binary_tree_helper.hpp>

namespace xstdtsl
{

	///
	/// a basic binary tree that doesn't self-balance
	///
	template <class T> class safe_avl_tree
	{
	public:
		typedef safe_avl_tree<T>												treetype;
		typedef binary_tree_helper::node<T>										nodetype;
		typedef T																datatype;
		typedef binary_tree_helper::read_iterator<safe_binary_tree,binary_tree_helper::node,datatype> 	read_iterator;
		typedef binary_tree_helper::read_control<safe_binary_tree,datatype> 			read_control;
		typedef binary_tree_helper::write_control<safe_binary_tree,datatype> 			write_control;
	protected:
		nodetype * 					m_pRoot; ///< the root of the tree
		mutable read_write_mutex	m_mMutex; ///< a read-write mutex for control of insertion, erasing, clearing, and searching the tree

		friend class binary_tree_helper::iterator_base<safe_binary_tree,binary_tree_helper::node,datatype>;
		friend class binary_tree_helper::read_iterator<safe_binary_tree,binary_tree_helper::node,datatype>;
		friend class binary_tree_helper::control_base<safe_binary_tree,datatype>;
		friend class binary_tree_helper::read_control<safe_binary_tree,datatype>;
		friend class binary_tree_helper::write_control<safe_binary_tree,datatype>;

	public:

		///
		/// void constructor; creates an empty tree; blocking(write)
		///
		safe_binary_tree(void) noexcept
		{
			m_pRoot = nullptr;
		}
		///
		/// copy constructor; creates a tree that is identical to an existing tree; blocking(read/write)
		///
		safe_binary_tree(const treetype & i_cRHO) noexcept(noexcept(T(std::declval<datatype>())))
		{
			write_lock_guard cLock(m_mMutex);
			m_pRoot = nullptr;
			nl_copy(i_cRHO);
		}
		///
		/// destructor; destroys the tree; blocking(write)
		///
		virtual ~safe_binary_tree(void) noexcept(noexcept(std::declval<datatype>().~datatype()))
		{
			write_lock_guard cLock(m_mMutex);
			if (m_pRoot != nullptr)
				delete m_pRoot;
			m_pRoot = nullptr;
		}
		///
		/// copy constructor; creates a tree that is identical to an existing tree; blocking(read/write)
		///
		safe_binary_tree & operator=(const treetype & i_cRHO) noexcept(noexcept(datatype(std::declval<datatype>())))
		{
			write_lock_guard cLock(m_mMutex);
			nl_copy(i_cRHO);
			return *this;
		}

	protected:
		///
		/// create a copy of an existing tree; blocking(read on tree to copy)
		///
		virtual void nl_copy(const treetype & i_cRHO) noexcept(noexcept(datatype(std::declval<datatype>())))
		{
			read_lock_guard cLock(i_cRHO.m_mMutex);
			if (m_pRoot != nullptr)
				delete m_pRoot;
			m_pRoot = nullptr;
			if (i_cRHO.m_pRoot != nullptr)
				m_pRoot = binary_tree_helper::create_node_copy<binary_tree_helper::node,datatype>(i_cRHO.m_pRoot,nullptr);
		}
		///
		/// insert a potentially new key into the tree
		///
		virtual void nl_insert(datatype i_tKey) noexcept(noexcept(datatype(std::declval<datatype>())))
		{
			binary_tree_helper::insert<binary_tree_helper::node,datatype>(m_pRoot,i_tKey);
		}
		///
		/// determine if a key exists within the tree; non-blocking
		/// \returns true if the key exists within the tree; false otherwise
		///
		virtual bool nl_has_key(datatype i_tKey) const noexcept
		{
			nodetype * pSearch_Result = nullptr;
			if (m_pRoot != nullptr)
				pSearch_Result = m_pRoot->search(i_tKey);
			return (pSearch_Result != nullptr);
		}
		
		///
		/// erase a node in the tree based on its key
		///
		virtual void nl_erase(datatype i_tKey) noexcept(noexcept(std::declval<datatype>().~datatype()))
		{
			nodetype * pSearch_Result = nullptr;
			if (m_pRoot != nullptr)
				pSearch_Result = m_pRoot->search(i_tKey);
			if (pSearch_Result != nullptr) // make sure the key is in the tree
			{
				nodetype * pParent = pSearch_Result->get_parent();

				// perform a right pivot with delete
				nodetype * pNew_Root = pSearch_Result->get_right();
				if (pNew_Root != nullptr)
				{
					// traverse the left children of the new root to find where to place the left children
					nodetype * pCurr = pNew_Root->get_left();
					nodetype * pLast = pNew_Root;
					while (pCurr != nullptr)
					{
						pLast = pCurr;
						pCurr = pCurr->get_left();
					}
					// add the left children of the deleted node to the left children of the identified edge
					pLast->set_left(pSearch_Result->get_left());
				}
				else // no right children; use the left child as the new root
				{
					pNew_Root = pSearch_Result->get_left();
				}
				// delete the erased node
				pSearch_Result->set_left(nullptr);
				pSearch_Result->set_right(nullptr);
				delete pSearch_Result;

				// place the new root and set its parent
				if (pNew_Root != nullptr)
					pNew_Root->set_parent(pParent);
				if (pParent != nullptr)
				{
					if (i_tKey < pParent->get_key()) // replace the left child
						pParent->set_left(pNew_Root);
					else
						pParent->set_right(pNew_Root);
				}
				else /// no parent and the key exists -- we are erasing the root of the tree
					m_pRoot = pNew_Root;
			}
		}
		///
		/// clear the tree; non-blocking
		///
		virtual void nl_clear(void) noexcept(noexcept(std::declval<datatype>().~datatype()))
		{
			if (m_pRoot != nullptr)
				delete m_pRoot;
			m_pRoot = nullptr;
		}

		///
		/// determine if the tree is empty
		///
		virtual bool nl_empty(void) const noexcept
		{
			return m_pRoot == nullptr;
		}

	public:
		///
		/// insert a new value into the key
		///
		virtual void insert(T i_tKey) noexcept(noexcept(T(std::declval<T>())))
		{
			write_lock_guard cLock(m_mMutex);
			nl_insert(i_tKey);
		}
		///
		/// erases a given key from the tree
		///
		virtual void erase(datatype i_tKey) noexcept(noexcept(std::declval<datatype>().~datatype()))
		{
			write_lock_guard cLock(m_mMutex);
			nl_erase(i_tKey);
		}
		///
		/// deletes all nodes in the tree
		///
		virtual void clear(void) noexcept(noexcept(std::declval<datatype>().~datatype()))
		{
			write_lock_guard cLock(m_mMutex);
			nl_clear();
		}
		///
		/// determine if a given key is in the tree
		/// \returns true if the key is in the tree; false otherwise
		///
		virtual bool has_key(datatype i_tKey) const noexcept
		{
			read_lock_guard cLock(m_mMutex);
			return nl_has_key(i_tKey);
		}
		
		///
		/// determine if the tree is empty
		/// \returns true if the tree is empty; false otherwise
		///
		virtual bool empty(void) const noexcept
		{
			read_lock_guard cLock(m_mMutex);
			return nl_empty();
		}


	};
}
#endif // #ifndef __XSTDTSL_SAFE_BINARY_TREE_H	
		public:
			///
			/// insert a new node if the given key is non-duplicate; will perform tree-balance if necessary per AVL algorithm
			/// \returns new root of tree
			///
			virtual void insert(avl_tree_node<T>* &io_pRoot, T i_tKey) noexcept(noexcept(T(std::declval<T>())))
			{ 
				std::cout << "AVL insert" << std::endl;
				if (i_tKey != node<T>::m_tKey)
				{
					// Insert the new key/node as normal BST insert
					if (i_tKey < node<T>::m_tKey)
					{
						if (node<T>::m_pLeft != nullptr)
							node<T>::m_pLeft = node<T>::m_pLeft->insert(i_tKey);
						else
							node<T>::m_pLeft = new avl_tree_node(this,i_tKey);
					}
					else if (i_tKey > node<T>::m_tKey)
					{
						if (node<T>::m_pRight != nullptr)
							node<T>::m_pRight = node<T>::m_pRight->insert(i_tKey);
						else
							node<T>::m_pRight = new avl_tree_node(this,i_tKey);
					}
					std::cout << "calculating heights at " << node<T>::m_tKey << std::endl;
					// Update height of this node
					int nLeft_Height = 0;
					int nRight_Height = 0;
					if (node<T>::m_pLeft != nullptr)
						nLeft_Height  = node<T>::m_pLeft->m_nHeight;
					if (node<T>::m_pRight != nullptr)
						nRight_Height  = node<T>::m_pRight->m_nHeight;
					m_nHeight = 1 + std::max(nLeft_Height,nRight_Height);
					int nBalance = nLeft_Height - nRight_Height; 

					// if the node is unbalanced
					if (nBalance > 1) // unbalanced to the left
					{
						std::cout << "XXXX rebalance > 1 " << std::endl;
						// Left Right Case 
						if (i_tKey > node<T>::m_tKey && node<T>::m_pLeft != nullptr) 
						{
							std::cout << "XXXX rebalance > 1 rotate left " << std::endl;
							node<T>::m_pLeft->rotate_left(io_pRoot);
						}
						// otherwise Left Left Case 
						rotate_right(io_pRoot); 
					}
					else if (nBalance < -1)  // unbalanced to the right
					{
						std::cout << "XXXX rebalance < -1 " << std::endl;
						// Right Left Case 
						if (i_tKey < node<T>::m_tKey && node<T>::m_pRight != nullptr) 
						{
							std::cout << "XXXX rebalance < -1 rotate right " << std::endl;
							node<T>::m_pRight->rotate_right(io_pRoot); 
						}
						// otherwise Right Right Case 
						rotate_left(io_pRoot); 
					}
				}
			} //function avl_tree_node* insert(T i_tKey)
		}; // class avl_tree_node
	} // namespace binary_trees

	template <class T> using safe_avl_tree = binary_trees::safe_binary_tree<T,binary_trees::avl_tree_node<T> > ;


} // namespace xstdtsl
#endif //#ifndef XSTDTSL_SAFE_AVL_TREE_H
